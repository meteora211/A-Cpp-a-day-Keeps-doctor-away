## Some thought

简单的题写了一个小时，想吐。
第一种方法用Vector实现，每一次循环都push_back进去结果供下一次循环使用，这种方法完全没有必要，两个字符串即可

改写第二种方法时思路被困住了:
首先，题目肯定是要统计上一次结果中相同字符的计数并与字符值放入下一次的结果中，不断循环。
问题在于，由于要比较字符串中res[j]和res[j+1]是否相等，所以j的取值不能超过字符长度-1。
这时跳入了一个误区，认为j的取值小于n-1, 因此最后一个字符值res[n-1]需要在循环外进行判断
其实，判断res[j+1] == res[j]时，只需要多加一个条件判断j是否要超出可取范围res.size()-1即可：
1 最后两个值相等的情况,这时候继续计数，下次循环后发现j超出可取范围，然后停止计数执行对temp对赋值语句即可
    x x x x x x x x x 1 1
                      ^ ^
                      j j+1
2 最后两个值不相等的情况，这时候停止计数，执行一次赋值语句且把计数器重置，然后循环继续，第二次判断发现j超出范围，在执行一次赋值语句退出循环。
    x x x x x x x x x 2 1
                      ^ ^
                      j j+1
